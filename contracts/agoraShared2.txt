// SPDX-License-Identifier: MIT


pragma solidity ^0.8.1;
import './agora.sol';




contract AgoraShare {
    
    uint public sharedId;

    struct SharedDrop  {
      address sharer;
      uint tokensleft;
      uint sold;
      uint tokenId;
      uint unitprice;
      Status state ;//{ Shared, Whole}
    
    }

    enum Status { Shared, Whole}
    Status state;

  //SharedDrop [] sharedDrops;

  mapping (uint => mapping (address => uint)) investors ;
  
  mapping (uint => SharedDrop) sharedDrops;
  
  
  //releases tokens for sale
  bool tokensAvailableForSale;


  event AgoraShared(
    uint Id,
    address indexed sharer,
    uint indexed tokenId,
    uint tokenQuanity,
    uint priceInWei,
    Status state
  );


  event buyAgoraShared(
    uint Id,
    uint indexed tokenId,
    uint totalPrice,
    uint amount,
    address indexed owner,
    address indexed buyer
  );

   
  event redeemAgoraShared(
    uint _sharedId,
    address indexed owner,
    uint amountgained
    );

   address AgoraNFTaddress;
   Agora agora;
   
  constructor(address _agoraNft) {
   sharedId = 0;
   AgoraNFTaddress = _agoraNft;
   agora = Agora(_agoraNft);
   //_mint(msg.sender, numberOfTokens * (10 ** 18));
  }

// GETTERS

    function getNFTAddress() public view returns(address) {
        return AgoraNFTaddress;
    }
    
    function getTokenOwner(uint _tokenId) public view returns(address) {
    
        return agora.ownerOf(_tokenId);
    }
    
    function getSharedId() public view returns(uint) {
    
        return sharedId;
    }
    
    function getInvestmentStatus(uint _sharedId) public view returns(uint) {
        return investors[_sharedId][msg.sender];
    }
    
// THE REST OF IT
    
    
    // create # of tokens to be offered and allocate equityOffered for sale, the rest to msg.sender(owner)
    
  function shareAgoraNft(uint _tokenId, uint numberOfTokens, uint equityOffered, uint raiseAmount) public {
    require(equityOffered < 100, "can't offer more than 100%");
    require(msg.sender == agora.ownerOf(_tokenId),"not owner");
    
    SharedDrop memory sharedDrop = 
    // sharedDrops[_tokenId];
    SharedDrop({
        sharer: msg.sender,
        // splitterContract : "",
        tokenId: _tokenId,
        tokensleft: numberOfTokens * equityOffered,
        sold: 0,
        unitprice: raiseAmount / ((numberOfTokens * equityOffered) / 100),
        state: Status.Shared
    });

    sharedDrops[_tokenId] = sharedDrop;
    //owner allocation of unoffered equity
    investors[sharedId][msg.sender] = numberOfTokens - ((numberOfTokens * equityOffered) / 100);
    
    //sharedId += 1;


  emit AgoraShared(sharedId - 1, 
                   sharedDrop.sharer,
                   sharedDrop.tokenId,
                   sharedDrop.tokensleft,
                   sharedDrop.unitprice,
                   sharedDrop.state
                   );
                   
  }
  
  //(bool sent, ) = owner.call{value: uint(adjustedPrice)}("");
                //require(sent, "Failed to send Ether");
                
    function buyShareinFilm2(uint _sharedId, uint amount) public {
      
    // require buyer has enough money to purchase the amount of tokens
    // subtract the amount sold from the tokensleft
    // add investors purchase to ledger in investors
     //uint tobuy =  sharedDrops[_sharedId].unitprice * amount;
     //require(sharedDrops[_sharedId].state == Status.Shared, "revert 1");
     //require( msg.value >= tobuy, "you don't have enough money");
     require( sharedDrops[_sharedId].tokensleft > amount, "revert 2");
     require( sharedDrops[_sharedId].tokensleft > 0, "revert 3");

                         
  }
  
 
/*
  function buyShareinFilm(uint _sharedId, uint amount) public {
      
    // require buyer has enough money to purchase the amount of tokens
    // subtract the amount sold from the tokensleft
    // add investors purchase to ledger in investors
     //uint tobuy =  sharedDrops[_sharedId].unitprice * amount;
     require(sharedDrops[_sharedId].state == Status.Shared, "Shares not yet available for that Id" );
     //require( msg.value >= tobuy, "you don't have enough money");
     require( sharedDrops[_sharedId].tokensleft > amount, "you're trying to purchase more tokens than exist");
     require( sharedDrops[_sharedId].tokensleft > 0, "all tokens sold");
     
      //sharedDrops[_sharedId].tokensleft -= amount;
      //sharedDrops[_sharedId].sold += amount;

    //  sharedDrops[_tokenId].share[_tokenId][msg.sender] = amount;

      //investorShares[_sharedId].push(msg.sender);

     //_transfer(sharedDrops[_sharedId].sharer, msg.sender, amount);

/*
  emit buyAgoraShared( _sharedId, 
                        sharedDrops[_sharedId].tokenId,
                         //tobuy,
                         amount,
                         amount,
                         address(this),
                         msg.sender );
                         
                         
  }
  
  */
  
  function releaseTokens() public {
      tokensAvailableForSale = true;
  }
  /*
  function authorizeViewing(uint16 sharedID) public view returns(bool) {
    uint arrayLength = investors[sharedID].length;
    for (uint i; i < arrayLength - 1 ; i++) {
        if (investorShares[sharedID][i].investor == msg.sender) {
            return true;
        }
    }
  }
  */

  function redeem ( uint _sharedId ) external {
    //  check if the sender is the owner
    // transfer sold token value to owner
    // send value to owner
      require(tokensAvailableForSale == true);
      require(msg.sender == sharedDrops[_sharedId].sharer, "not owner bros");
      uint amountsold = sharedDrops[_sharedId].sold * sharedDrops[_sharedId].unitprice ;
      payable(msg.sender).transfer(amountsold);
      
      emit redeemAgoraShared( _sharedId,
                              msg.sender,
                              amountsold

      );
  }
}

  // function buyOut(){
    // This function calls the getInvestor and getShares function
    // creates a newPaymentSplitter ---- redeploys at every instance with getInvestor and getShares
    // ----------------------------if there's enough time, we can consider gelato for automation  for redeployment of payment spiltter
    // then splits amongst investors
    // then burn sharedDrops
    // then transfer ERC721.transfer to buyer
  //    new PaymentSplitter()
  // this is to be done preferably in NodeJS
  // }
/*
 function setSplitContract( uint tokenId, address _splitter) internal{
   require(msg.sender == sharedDrops[tokenId].sharer);
   splitterContract[tokenId] = _splitter;
 }
*/

/*
// --------------------------------------getters-----------------------------------
  function getInvestor(uint16 _sharedId) internal view returns ( address [] memory) {
   return  investors[_sharedId];
  }

  function getInvestorNShares(uint16 _sharedId) external  returns (address [] memory, uint [] memory) {
    // uint[] storage knownShares;
    investors [_sharedId] = getInvestor(_sharedId);
    uint16 i = 0;
    while( investors[_sharedId].length > i )
    {
       knownShares.push(share[_sharedId][investors[_sharedId][i]]) ;

    }
  //  for (uint16 i = 0; i++; i <= investors[tokenId].length){
  //     knownShares.push(
  //        share[tokenId][investors[i]]
        
  //       // sharedDrops[tokenId].shares[tokenId].investors[i] 
  //       );
  //  }
  // return (investors, knownShares);
  return (investors[_sharedId], knownShares);
  }
}

*/